
\documentclass[a4paper,14pt]{extarticle}

\usepackage{cmap}

\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}

\usepackage[a4paper,margin=1.5cm,footskip=1cm,left=2cm,right=1.5cm,top=1.5cm
	,bottom=2.0cm]{geometry}
\usepackage{textcase}
\usepackage{csquotes}
\usepackage{enumitem}

\usepackage[labelsep=period,justification=centering]{caption}

\usepackage{amsmath}
\usepackage{pgfplots}

\usepackage{float}

\usepackage{indentfirst}

\usepackage{textgreek}

\setlist[description]{leftmargin=\parindent,labelindent=\parindent}

\begin{document}

\setcounter{secnumdepth}{0}

\begin{titlepage}

	\begin{center}
		Новосибирский государственный технический университет
		
		Факультет прикладной математики и информатики
		
		Кафедра теоретической и прикладной информатики
		
		\vspace{250pt}
		
		\textbf{\LARGE{Лабораторная работа № 2}}
		\medbreak
		\small{по дисциплине \\
		\medbreak
		<<Математические методы планирования эксперимента>>}
		\vspace{100pt}
	\end{center}

	\begin{flushleft}
		\begin{tabbing}
			Группа:\qquad\qquad \= ПММ-61\\
			Студент:            \> Горбунов К. К.\\
			Преподаватели:      \> доц. Черникова О. С.\\
			                    \> доц. Филиппова Е. В.
		\end{tabbing}
	\end{flushleft}

	\begin{center}
		\vspace{\fill}
		Новосибирск, 2017 г.
	\end{center}

\end{titlepage}

\newpage

\renewenvironment{knitrout}{\setlength{\topsep}{0mm}}{}

\section{Цель работы}

Ознакомиться с двойственной процедурой синтеза непрерывных планов эксперимента.

\section{Задание к лабораторной работе}

\begin{enumerate}
	\item Написать программу, реализующую двойственную градиентную процедуру
		планирования D-оптимальных входных сигнало сигналов для регрессионных
		моделей.
	\item Округлить полученные непрерывные планы эксперимента до дискретных
		планов, в соответствии с алгоритмом, реализованным в лабораторной работе
		№ 1.
	\item Проверить правильность работы программ на моделях с различным числом
		варьируемых параметров.
\end{enumerate}


\section{Ход работы}

\subsection{Вспомогательные процедуры}

<<options, echo=FALSE, cache=FALSE>>=
opts_chunk$set(warning=TRUE, purl=FALSE, cache=TRUE, autodep=TRUE)
dep_auto()
options(digits=5, width=60)
@

<<optplan-function, purl=T>>=
optplan <- function(s) {
	l <- list(c(-1,1))
	l <- rep(l, s)
	dfeg <- expand.grid(l)
	q <- s2q(s)
	p <- rep(1/q, q)
	A <- data.matrix(dfeg)
	A <- A[1:q,]
	return(list(A=A, p=p, q=q))
}
@

<<functions>>=
s2q <- function(s) s * (s + 1) / 2 + 1

genInitData <- function(s)
{
	q <- s2q(s)

	th <- runif(s, min=-1, max=1)

	a <- runif(s*q, min=-1, max=1)

	A <- matrix(a, nrow=q)

	p <- rep(1/q, q)

	# NOTE: q not needed
	return(list(th=th, A=A, p=p, q=q))
}

# information matrix
# TODO: add intercept
M <- function(a, th)
{
	f <- th * a
	rez <- f %*% t(f)
	return(rez)
}

Mxi <- function(u, th)
{
	q <- length(u) / (length(th) + 1)

	a <- head(u, n=-q)

	p <- tail(u, n=q)

	A <- matrix(a, nrow=q)

	# list of matrices for every point of the plan
	Mi <- plyr::alply(A, 1, M, th=th)

	# multiply by weights 'p'
	Mi <- Map('*', Mi, p)

	# normalized information matrix
	Mxi <- Reduce('+', Mi)

	return(Mxi)
}

# u = c(A,p)
X <- function(u, th)
{
	Mxi <- Mxi(u, th)

	return(-log(det(Mxi)))
}

Sp <- function(x) sum(diag(x))

μ <- function(a, Mxi, th) Sp(solve(Mxi) %*% M(a, th))

#η <- s

hina <- function(a)
{
	h <- 1 - a
	h <- c(h, a + 1)
	return(h)
}

Xτ <- function(τ, a, u, th)
{
	s <- length(th)
	q <- s2q(s)
	p <- tail(u, n=q)
	A <- head(u, n=-q)
	A <- matrix(A, nrow=q)

	A <- rbind(A, a)
	p <- p - τ / q
	p <- c(p, τ)

	Xτ <- X(c(A, p), th)

	return(Xτ)
}

dualproc <- function(A, p, th)
{
	library(nloptr)
	library(RANN)

	δ <- 1e-6
	s <- length(th)
	η <- s

	# 1
	Mxi <- Mxi(c(A, p), th)

	a <- rep(0, length(th))

	repeat {
		repeat {
			# 2
			l <- slsqp(a, function(a, Mxi, th) -μ(a, Mxi, th), hin=hina, Mxi=Mxi,
								 th=th) # NOTE: should initial 'a' be changed?
			a <- l$par

			if (abs(μ(a, Mxi, th) - η) <= δ)
				return(list(A=A, p=p))

			if (μ(a, Mxi, th) > η)
				break
			# else go to 2
		}

		# 3
		l <- slsqp(0, Xτ, hin=function(τ) c(τ, 1 - τ), a=a, u=c(A, p), th=th)
		τ <- l$par

		# 4: add 'a' to plan
		A <- rbind(A, a)
		p <- c(p, τ)

		l <- clean(list(A=A, p=p))
		A <- l$A
		p <- l$p

		# and continue
	}
	return(list(A=A, p=p))
}
@

<<clean-plan>>=
clean <- function(l)
{
	dp <- 1e-2
	dn <- 1e-2
	A <- l$A
	p <- l$p
	q <- length(p)

	# clean by weight
	i <- which(p <= dp)
	if (length(i) != 0) {
		p[-i] <- p[-i] + sum(p[i]) / length(p[-i])
		p <- p[-i]
		A <- A[-i]
	}

	# clean by distance
	i <- 1
	while (i <= q - 1)
	{
		j <- i + 1
		while (j <= q)
		{
			r <- A[i,] - A[j,]
			n <- norm(r, 'F')
			if (n <= dn)
			{
				# merge i and j points
				px <- sum(p[c(i,j)])
				x <- 1 / px * (p[i] * A[i,] + p[j] * A[j,])
				A <- A[-c(i,j),]
				A <- rbind(A, x)
				p <- p[-c(i,j)]
				p <- c(p, px)
				i <- i - 1
				j <- j - 1
				q <- q - 1
			}
			j <- j + 1
		}
		i <- i + 1
	}
	return(list(A=A, p=p))
}
@

<<constraints, purl=T>>=
# equalities constraints
heq <- function(u) {
	# FIXME: q - global variable
	p <- tail(u, n=q)
	return(sum(p) - 1)
}

# inequalities constraints
hin <- function(u) {
	# FIXME: q is global variable
	p <- tail(u, n=q)
	a <- head(u, n=-q)
	h <- p - rep(1e-9, length(p))
	h <- c(h, 1 - a)
	h <- c(h, a + 1)
	return(h)
}
@

\subsection{Начальный план}



\subsection{Нахождение оптимального плана}



\section*{Заключение}

Заключение.

\begin{thebibliography}{9}

\begin{sloppypar}

\bibitem{mono} Активная параметрическая идентификация стохастических линейных
	систем: монография / В.И. Денисов, В.М. Чубич, О.С. Черникова, Д.И. Бобылева.
		--- Новосибирск : Изд-во НГТУ, 2009. --- 192 с.
		(Серия <<Монографии НГТУ>>).

\end{sloppypar}

\bibitem{knitr16} Yihui Xie (2016). knitr: A General-Purpose Package for
	Dynamic Report Generation in R. R package version 1.15.1.

\end{thebibliography}

\end{document}

# vim: ts=2 sw=2
