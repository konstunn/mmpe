
\documentclass[a4paper,14pt]{extarticle}

\usepackage{cmap}

\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}

\usepackage[a4paper,margin=1.5cm,footskip=1cm,left=2cm,right=1.5cm,top=1.5cm
	,bottom=2.0cm]{geometry}
\usepackage{textcase}
\usepackage{csquotes}
\usepackage{enumitem}

\usepackage[labelsep=period,justification=centering]{caption}

\usepackage{amsmath}
\usepackage{pgfplots}

\usepackage{float}

\usepackage{indentfirst}

\setlist[description]{leftmargin=\parindent,labelindent=\parindent}

\begin{document}

\setcounter{secnumdepth}{0}

\begin{titlepage}

	\begin{center}
		Новосибирский государственный технический университет
		
		Факультет прикладной математики и информатики
		
		Кафедра теоретической и прикладной информатики
		
		\vspace{250pt}
		
		\textbf{\LARGE{Лабораторная работа № 1}}
		\medbreak
		\small{по дисциплине \\
		\medbreak
		<<Математические методы планирования эксперимента>>}
		\vspace{100pt}
	\end{center}

	\begin{flushleft}
		\begin{tabbing}
			Группа:\qquad\qquad \= ПММ-61\\
			Студент:            \> Горбунов К. К.\\
			Преподаватели:      \> доц. Черникова О. С.\\
													\> доц. Филиппова Е. В.
		\end{tabbing}
	\end{flushleft}

	\begin{center}
		\vspace{\fill}
		Новосибирск, 2017 г.
	\end{center}

\end{titlepage}

\newpage

\renewenvironment{knitrout}{\setlength{\topsep}{0mm}}{}

\section{Цель работы}

Ознакомиться с прямой процедурой синтеза непрерывных планов эксперимента.

\subsection{Задание к лабораторной работе}

\begin{enumerate}
	\item Написать программу, реализующую прямую градиентную процедуру
		планирования D-оптимальных входных сигналов для регрессионных
		моделей.
	\item Реализовать алгоритм округления непрерывного плана эксперимента до
		дискретного плана в соотвествии с алгоритмом из лекции <<Теоретические
		аспекты планирования входных сигналов>>.
	\item Проверить правильность работы программ на моделях с различным числом
		варьируемых параметров.
\end{enumerate}

\section{Ход работы}

<<chunk-opts-set>>=
opts_chunk$set(warning=T, purl=F)
@

<<functions, purl=T>>=
genInitData <- function(s)
{
	# TODO: generate non-singular initial plan!

	# number of input signals in the plan
	q <- s * (s + 1) / 2 + 1

	# model parameters (theta)
	th <- runif(s, min=-1, max=1)

	# input data (alpha)
	a <- runif(s*q, min=-1, max=1)
	# NOTE: from -1 to 1

	A <- matrix(a, byrow=T, nrow=q)

	# initial random weights
	p <- runif(q)

	# normalize
	p <- p / sum(p)

	return(list(th=th, A=A, p=p, q=q))
}

# information matrix
M <- function(a, th)
{
	f <- th * a
	rez <- f %*% t(f)
	return(rez)
}

# -log(det(M))
mldm <- function(u, th)
{
	q <- length(u) / (length(th) + 1)

	a <- head(u, n=-q)

	p <- tail(u, n=q)

	A <- matrix(a, nrow=q)

	# list of matrices for every point of the plan
	Mi <- plyr::alply(A, 1, M, th=th)

	# multiply by weights 'p'
	Mi <- Map('*', Mi, p)

	# normalized information matrix
	Mxi <- Reduce('+', Mi)

	mldm <- -log(det(Mxi))

	return(mldm)
}
@

<<chunk>>=
set.seed(104)

# number of parameters
s <- 2

L <- genInitData(s)

# print initial data
(A <- L$A)
(p <- L$p)
q <- L$q
th <- L$th

(val <- mldm(c(A, p), th))
@

<<constraints, purl=T>>=
# equalities constraints
heq <- function(u) {
	p <- tail(u, n=q)
	return(sum(p) - 1)
}

# inequalities constraints
hin <- function(u) {
	p <- tail(u, n=q)
	a <- head(u, n=-q)
	alen <- length(a)
	cond <- p > rep(0, q)
	cond <- c(cond, a > rep(-1, alen))
	cond <- c(cond, a < rep(1, alen))
	if (all(cond))
		return(1)
	else
		return(-1)
}
@

<<solve, warning=T>>=
library(nloptr)
l <- nl.opts(list(xtol_rel = 1e-8, maxeval=3000))
(l <- slsqp(c(A, p), mldm, hin=hin, heq=heq, th=th))
@

<<sqp2plan, purl=T>>=
sqp2plan <- function(l, q) {
	u <- l$par
	p <- tail(u, n=q)
	A <- head(u, n=-q)
	A <- matrix(A, nrow=q)
	value <- l$value
	return(list(A=A, p=p, value=value))
}
@

<<solution>>=
# print plan
l <- sqp2plan(l, q)
(val <- l$value)

(p <- l$p)
(A <- l$A)
@

Значение критерия: \Sexpr{val}

<<clean-plan>>=
# find point with minimal weight
i <- which(p == min(p))
p[i] # weight of the point to remove
A <- A[-i,] # remove the point

# redistribute weights
p <- p + rep(p[i] / (q-1), length(p))

p <- p[-i]

# print plan
p
A

# criterion value
(val <- mldm(c(A, p), th))
@

Значение критерия: \Sexpr{val}

<<optplan-function, purl=T>>=
optplan <- function(s) {
	l <- list(c(-1,1))
	l <- rep(l, s)
	dfeg <- expand.grid(l)
	q <- 2^s
	p <- rep(1/q, q)
	A <- data.matrix(dfeg)
	return(list(A=A, p=p, q=q))
}
@

<<optplan>>=
# TODO: extract to function
l <- optplan(s)
q <- l$q
(p <- l$p)
(A <- l$A)

(val <- mldm(c(A, p), th))
@

Значение критерия: \Sexpr{val}

<<subopt>>=
A <- A * 0.8
(val <- mldm(c(A, p), th))
(l <- slsqp(c(A, p), mldm, hin=hin, heq=heq, th=th))
(l <- sqp2plan(l, q))
@

\section*{Заключение}

Заключение.

\begin{thebibliography}{9}

\begin{sloppypar}

\bibitem{mono} Активная параметрическая идентификация стохастических линейных
	систем: монография / В.И. Денисов, В.М. Чубич, О.С. Черникова, Д.И. Бобылева.
		--- Новосибирск : Изд-во НГТУ, 2009. --- 192 с. (Серия <<Монографии НГТУ>>).

\end{sloppypar}

\bibitem{knitr16} Yihui Xie (2016). knitr: A General-Purpose Package for Dynamic
	Report Generation in R. R package version 1.15.1.

\end{thebibliography}

\end{document}

# vim: ts=2 sw=2
