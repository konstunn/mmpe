
\documentclass[a4paper,14pt]{extarticle}

\usepackage{cmap}

\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}

\usepackage[a4paper,margin=1.5cm,footskip=1cm,left=2cm,right=1.5cm,top=1.5cm
	,bottom=2.0cm]{geometry}
\usepackage{textcase}
\usepackage{csquotes}
\usepackage{enumitem}

\usepackage[labelsep=period,justification=centering]{caption}

\usepackage{amsmath}
\usepackage{pgfplots}

\usepackage{float}

\usepackage{indentfirst}

\usepackage{textgreek}

\setlist[description]{leftmargin=\parindent,labelindent=\parindent}

\begin{document}

\setcounter{secnumdepth}{0}

\begin{titlepage}

	\begin{center}
		Новосибирский государственный технический университет
		
		Факультет прикладной математики и информатики
		
		Кафедра теоретической и прикладной информатики
		
		\vspace{250pt}
		
		\textbf{\LARGE{Лабораторная работа № 3}}
		\medbreak
		\large{<<Вычисление информационной матрицы для стохастических дискретных
		моделей>>} \\
		\medbreak
		\small{по дисциплине \\
		\medbreak
		<<Математические методы планирования эксперимента>>}
		\vspace{100pt}
	\end{center}

	\begin{flushleft}
		\begin{tabbing}
			Группа:\qquad\qquad \= ПММ-61\\
			Студент:            \> Горбунов К. К.\\
			Преподаватели:      \> доц. Черникова О. С.\\
			                    \> доц. Филиппова Е. В.
		\end{tabbing}
	\end{flushleft}

	\begin{center}
		\vspace{\fill}
		Новосибирск, 2017 г.
	\end{center}

\end{titlepage}

\newpage

\renewenvironment{knitrout}{\setlength{\topsep}{0mm}}{}

\section{Цель работы}

Ознакомиться с двойственной процедурой синтеза непрерывных планов эксперимента.

\section{Задание к лабораторной работе}

\begin{enumerate}
	\item Написать программу, реализующую двойственную градиентную процедуру
		планирования D-оптимальных входных сигнало сигналов для регрессионных
		моделей.
	\item Округлить полученные непрерывные планы эксперимента до дискретных
		планов, в соответствии с алгоритмом, реализованным в лабораторной работе
		№ 1.
	\item Проверить правильность работы программ на моделях с различным числом
		варьируемых параметров.
\end{enumerate}

Модель 1:

\begin{equation}
\label{eq:mod1}
\left\{
	\begin{array}{lll}
		x(t_{k+1}) &= \theta_1 x(t_k) + \theta_2 u(t) + w(t), \\
		y(t_{k+1}) &= x(t_{k+1}) + v(t_{k+1}),\ k = 0, 1.
	\end{array}
\right.
\end{equation}

\[
	Q = 0.1, R = 0.3, \bar{x}(t_0) = 0, P_0 = 0.1, \\
	u(t_0) = u(t_1) = 2, \theta_1 = 1, \theta_1 = 1
\]

<<MM>>=
M <- c(8.35, 12.31, 12.31, 27.7)
M <- matrix(M, nrow=2, ncol=2, byrow=TRUE)
@

Ответ:

<<M>>=
M
@

Модель 2:

\begin{equation}
\label{eq:mod2}
\left\{
	\begin{array}{lll}
		x(t_{k+1}) &= \theta_1 x(t_k) + \theta_2 u(t) + w(t), \\
		y(t_{k+1}) &= x(t_{k+1}) + v(t_{k+1}),\ k = 0, 1.
	\end{array}
\right.
\end{equation}

\section{Ход работы}

\subsection{Вспомогательные процедуры}

<<options, echo=FALSE, cache=FALSE, purl=F>>=
opts_chunk$set(purl=TRUE, cache=TRUE, autodep=TRUE, tidy=TRUE)
dep_auto()
options(digits=5, width=60, formatR.indent=4)
@

<<model>>=
Phi <- function(th) {}

Psi <- function(th) {}

H <- function(th) {}
@

<<matderiv>>=
library(numDeriv)
# returns list of partial derivatives of matrices by theta_i
# A - matrix-function
matderiv <- function(A, th)
{
	dA <- jacobian(A, th)

	A <- A(th)

	f <- function(a) list(matrix(a, nrow=nrow(A), ncol=ncol(A)))

	dA <- apply(dA, 2, f)

	dA <- Reduce(c, dA)

	return(dA)
}

<<dK_>>=
K_ <- function(P, th)
{
	H <- H(th)
	Phi(th) %*% P %*% t(H) %*% solve(H %*% P %*% t(H) + R(th))
}
@

<<PhiA>>=
PhiA <- function(Phi, K_, dPhi, H, dH)
{
	s <- ncol(Phi)

	first_col <- dPhi - K_ %*% dH
	first_col <- c(Phi, first_col)

	diag <- Phi - K_ %*% H
	diag <- replicate(s, diag, simplify=F)
	diag <- Matrix::bdiag(diag)

	PhiA <- rbind(rep(0, ncol(diag)), diag)
	PhiA <- cbind(first_col, PhiA)

	return(PhiA)
}
@

<<Mf>>=
# TODO: put all parameters in a list, take a single list as an argument
# input arguments are all functions, except for 'th' and 'u'
M <- function(Phi, Psi, Gam, H, Q, R, X_0, P0, th, u)
{
	# 1
	# these are lists whose elements are derivatives of matrices by each theta_i
	dPhi <- matderiv(Phi, th)
	dPsi <- matderiv(Psi, th)
	dGam <- matderiv(Gam, th)
	dH <-	matderiv(H, th)
	dQ <- matderiv(Q, th)
	dR <- matderiv(R, th)
	dX_0 <- matderiv(X_0, th)
	dP0 <- matderiv(P0, th)

	# now these are numeric matrices
	Phi <- Phi(th)
	Psi <- Psi(th)
	Gam <- Gam(th)
	H <- H(th)
	Q <- Q(th)
	R <- R(th)
	X_0 <- X_0(th)
	P_0 <- P_0(th)

	PsiA <- rbind(Psi, dPsi)

	# TODO: come back here soon to complete
	# 2
	Mth <- 0
	P <- P0
	dP <- dP0
	k <- 0

	# 3
	K_ <- K_(P, th)
	dK_ <- matderiv(K_, th)

	K_A <- rbind(K_, dK_)

	PhiA <- PhiA(Phi, K_, dPhi, H, dH)

	B <- P %*% P %*% t(H) + R

	if (k > 0)
		EAp <- PhiA %*% EA %*% t(PhiA) + K_A %*% B %*% t(K_A)
	else
		EAp <- 0

	# 4
	n <- nrow(X_0)

	factors <- c(sapply(1:s, function(a) rep(a, n)))

	dX_0 <- split(dX_0, factors)

	Phi_dX_0 <- Map('%*%', Phi, dX_0)

	Reduce(rbind, Phi_dX_0)

	if (k > 0)
		X_Ap <- PhiA %*% X_Ap + PsiA %*% u[k+1]
	else
		X_Ap <- 
			rbind(Phi, dPhi) %*% X_0 + 
			rbind(rep(0, n), Phi_dX_0) + 
			PsiA %*% u[k+1]

	dX_0 <- Reduce(rbind, dX_0)

	# 5
	Pp <- Phi %*% P %*% t(Phi) + Gam %*% Q %*% t(Gam)
	Bp <- H %*% Pp %*% t(H) + R
	Kp <- Pp %*% t(H) %*% solve(Bp)
	n <- nrow(Phi)
	I <- diag(n)
	Pu <- (I - Kp %*% H) %*% Pp
	K_ <- Phi %*% Kp

	# 6
	# PhiA(t+2, t+1)
	PhiA <- PhiA(K_, Phi, dPhi, H, dH, th)

	# 7
	# dP, dB, dK, dP, dK_
	#dPp <- pred_dP()
	#dB
	#dK
	#dPu
	#dK_

	# 8
	# K_A <- K_A(K_, th)

	# 9
	# AM

	# 10
	#M <- M + AM

	# 11
	# if (t <= N-1)
	# TODO: make loop
	#		continue
	# else
	#		return(M)
}
@

\section*{Заключение}

Заключение.

\begin{thebibliography}{9}

\begin{sloppypar}

\bibitem{mono} Активная параметрическая идентификация стохастических линейных
	систем: монография / В.И. Денисов, В.М. Чубич, О.С. Черникова, Д.И. Бобылева.
		--- Новосибирск : Изд-во НГТУ, 2009. --- 192 с.
		(Серия <<Монографии НГТУ>>).

\end{sloppypar}

\bibitem{knitr16} Yihui Xie (2016). knitr: A General-Purpose Package for
	Dynamic Report Generation in R. R package version 1.15.1.

\end{thebibliography}

\end{document}

# vim: ts=2 sw=2
