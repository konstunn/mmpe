
\documentclass[a4paper,14pt]{extarticle}

\usepackage{cmap}

\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}

\usepackage[a4paper,margin=1.5cm,footskip=1cm,left=2cm,right=1.5cm,top=1.5cm
	,bottom=2.0cm]{geometry}
\usepackage{textcase}
\usepackage{csquotes}
\usepackage{enumitem}

\usepackage[labelsep=period,justification=centering]{caption}

\usepackage{amsmath}
\usepackage{pgfplots}

\usepackage{float}

\usepackage{indentfirst}

\usepackage{textgreek}

\setlist[description]{leftmargin=\parindent,labelindent=\parindent}

\begin{document}

\setcounter{secnumdepth}{0}

\begin{titlepage}

	\begin{center}
		Новосибирский государственный технический университет
		
		Факультет прикладной математики и информатики
		
		Кафедра теоретической и прикладной информатики
		
		\vspace{250pt}
		
		\textbf{\LARGE{Лабораторная работа № 3}}
		\medbreak
		\large{<<Вычисление информационной матрицы для стохастических дискретных
		моделей>>} \\
		\medbreak
		\small{по дисциплине \\
		\medbreak
		<<Математические методы планирования эксперимента>>}
		\vspace{100pt}
	\end{center}

	\begin{flushleft}
		\begin{tabbing}
			Группа:\qquad\qquad \= ПММ-61\\
			Студент:            \> Горбунов К. К.\\
			Преподаватели:      \> доц. Черникова О. С.\\
			                    \> доц. Филиппова Е. В.
		\end{tabbing}
	\end{flushleft}

	\begin{center}
		\vspace{\fill}
		Новосибирск, 2017 г.
	\end{center}

\end{titlepage}

\newpage

\renewenvironment{knitrout}{\setlength{\topsep}{0mm}}{}

\section{Цель работы}

Ознакомиться с двойственной процедурой синтеза непрерывных планов эксперимента.

\section{Задание к лабораторной работе}

\begin{enumerate}
	\item Написать программу, реализующую двойственную градиентную процедуру
		планирования D-оптимальных входных сигнало сигналов для регрессионных
		моделей.
	\item Округлить полученные непрерывные планы эксперимента до дискретных
		планов, в соответствии с алгоритмом, реализованным в лабораторной работе
		№ 1.
	\item Проверить правильность работы программ на моделях с различным числом
		варьируемых параметров.
\end{enumerate}

Модель 1:

\begin{equation}
\label{eq:mod1}
\left\{
	\begin{array}{lll}
		x(t_{k+1}) &= \theta_1 x(t_k) + \theta_2 u(t) + w(t), \\
		y(t_{k+1}) &= x(t_{k+1}) + v(t_{k+1}),\ k = 0, 1.
	\end{array}
\right.
\end{equation}

\[
	Q = 0.1, R = 0.3, \bar{x}(t_0) = 0, P_0 = 0.1, \\
	u(t_0) = u(t_1) = 2, \theta_1 = 1, \theta_1 = 1
\]

<<>>=
M <- c(8.35, 12.31, 12.31, 27.7)
M <- matrix(M, nrow=2, ncol=2, byrow=TRUE)
@

Ответ:

<<>>=
M
@

Модель 2:

\begin{equation}
\label{eq:mod2}
\left\{
	\begin{array}{lll}
		x(t_{k+1}) &= \theta_1 x(t_k) + \theta_2 u(t) + w(t), \\
		y(t_{k+1}) &= x(t_{k+1}) + v(t_{k+1}),\ k = 0, 1.
	\end{array}
\right.
\end{equation}

\section{Ход работы}

\subsection{Вспомогательные процедуры}

<<options, echo=FALSE, cache=FALSE, purl=F>>=
opts_chunk$set(purl=TRUE, cache=TRUE, autodep=TRUE, tidy=TRUE)
dep_auto()
options(digits=5, width=60, formatR.indent=4)
@

<<model-matrices>>=
Phi <- function(th) {}

Psi <- function(th) {}

H <- function(th) {}
@

<<<B>>=
B <- function(Pp, th)
{
	H <- H(th)

	B <- H %*% Pp %*% t(H) + R(th)
	return(B)
}
@

<<matderiv>>=
matderiv(A, th) 
{
	dA <- jacobian(A, th)

	f <- function(a) matrix(a, nrow=nrow(A), ncol=ncol(A))
	
	dA <- apply(dA, 2, f)
}

<<K>>=
K <- function(Pp, th) {
	B <- B(Pp, th)
	K <- Pp %*% t(H(th)) %*% solve(B)
}
 
K_ <- function(Pp, th)
	Phi(th) %*% K(Pp, th)

K_A <- function(K_, th)
{
	dK_ <- matderiv(K_, th)
	K_A <- Reduce(rbind, c(K_, dK_))
	return(K_A)
}
@

<<PhiA>>=
PhiA <- function(Pp, dPhi, dH , th)
{
	s <- length(th)
	K_ <- K_(Pp, th)

	dPhi <- Reduce(rbind, dPhi)
	dH <- Reduce(rbind, dH)

	1st_col <- dPhi - K_ %*% dH
	1st_col <- c(Phi, 1st_col)

	Phi_Kk_H <- Phi - K_ %*% H(th)
	Phi_Kk_H <- replicate(s, Phi_Kk_H, simplify=F)
	Matrix::bdiag(Phi_Kk_H)
}
@

<<EA>>=
predictEA(EA) {
}
@

<<M>>=
# TODO: put all parameters in a list, take a single list as an argument
M <- function(Phi, Psi, Gam, H, Q, R, Ex0, P0, th)
{
	# 1
	# these are lists whose elements are matrices of derivatives by each theta_i
	dPhi <- matderiv(Phi, th)
	dPsi <- matderiv(Psi, th)
	dGam <- matderiv(Gam, th)
	dH <-	matderiv(H, th)
	dQ <- matderiv(Q, th)
	dR <- matderiv(R, th)
	dEx0 <- matderiv(Ex0, th)
	dP0 <- matderiv(P0, th)

	PsiA <- Reduce(rbind, c(Psi, dPsi))

	# 2
	Mth <- 0
	P00 <- P0
	dP00 <- dP0
	t <- 0

	# 3
	if (k)
	#	:
	else
		EA <- 0
}
@

\section*{Заключение}

Заключение.

\begin{thebibliography}{9}

\begin{sloppypar}

\bibitem{mono} Активная параметрическая идентификация стохастических линейных
	систем: монография / В.И. Денисов, В.М. Чубич, О.С. Черникова, Д.И. Бобылева.
		--- Новосибирск : Изд-во НГТУ, 2009. --- 192 с.
		(Серия <<Монографии НГТУ>>).

\end{sloppypar}

\bibitem{knitr16} Yihui Xie (2016). knitr: A General-Purpose Package for
	Dynamic Report Generation in R. R package version 1.15.1.

\end{thebibliography}

\end{document}

# vim: ts=2 sw=2
